# Практическая работа №1. «Делимся проектом с миром»

**Сделать папку репозиторием —** `git init`

**«Разгитить» папку, если что-то пошло не так, —** `rm -rf .git`

**Проверить состояние репозитория —** `git status`

**Подготовить файлы к сохранению —** `git add`

**Например:**
```bash
git add --all
git add readme.txt
```
**Выполнить коммит** — `git commit`

**Просмотреть историю коммитов —** `git log`

**GitHub быстрый старт** (https://docs.github.com/ru/get-started/quickstart)

**Для генерации SSH-пары можно использовать программу ssh-keygen.**

Откройте терминал и введите следующую команду.
```bash
ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub" 
```
**Для добавления сгенерированного ключа:**
1. Перейдите на GitHub и выберите пункт Settings (англ. «настройки») в меню аккаунта.
2. В меню слева нажмите на пункт SSH and GPG keys.
3. В открывшейся вкладке выберите New SSH key (англ. «новый SSH-ключ»).
4. В поле Title (англ. «заголовок») напишите название ключа. Например, Personal key (англ. «личный ключ»).
5. В поле Key type (англ. «тип ключа») должно быть Authentication Key (англ. «ключ аутентификации»).
6. В поле Key скопируйте ваш ключ из файла .pub.
7. Нажмите на кнопку Add SSH key (англ. «добавить SSH-ключ»).
8. Проверьте правильность ключа с помощью следующей команды.
```bash
ssh -T git@github.com 
```
**Привязать удаленный репозиторий к локальному**
```bash
cd ~/dev/first-project
git remote add origin git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ_РЕПОЗИТОРИЯ%.git 
```
**Убедиться, что репозитории связаны, —** `git remote -v`
**Отправить изменения на удалённый репозиторий —** `git push`
```bash
git push -u origin main # Если команда приведёт к ошибке, попробуйте 
                          # заменить main на master.
```						  
**Форматирование README.md** (https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c)

**Хеш — основной идентификатор коммита**

Git хеширует (преобразует) информацию о коммите с помощью алгоритма SHA-1 и получает для каждого коммита свой уникальный хеш — результат хеширования.
Обычно хеш — это короткая (40 символов в случае SHA-1) строка.

Она обладает следующими важными свойствами:

  * если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;
  * если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).	

**Элементы описания коммита**

После вызова `git log` появляется список коммитов. 

Формат вывода:

* строка из цифр и латинских букв после слова commit — это хеш коммита;
* Author — имя автора и его электронная почта;
* Date — дата и время создания коммита;
* в конце находится сообщение коммита.

Получить сокращённый лог можно с помощью команды `git log --oneline`

Сокращённый хеш (то есть первые несколько символов полного) можно использовать точно так же, как и полный. Для этого команда `git log --oneline` автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь.

**HEAD — всему голова**

Файл `HEAD` — один из служебных файлов папки `.git`. Он указывает на коммит, который сделан последним (то есть на самый новый).

Если нужно передать последний коммит, то вместо его хеша можно просто написать слово `HEAD` — Git поймёт, что вы имели в виду последний коммит.

**Статусы файлов в Git**

Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные.

* `untracked` Новые файлы в Git-репозитории помечаются как `untracked`, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У `untracked`-файла нет предыдущих версий, зафиксированных в коммитах или через команду `git add`.
* `staged`  После выполнения команды `git add` файл попадает в ** staging area**, то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии `staged`. ** Staging area** также называют ** index** или ** cache**, а состояние файла `staged` иногда называют `indexed` или `cached`.
* `tracked` Состояние `tracked` — это противоположность `untracked`. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью `git commit`, а также файлы, которые были добавлены в ** staging area** командой `git add`. То есть все файлы, в которых Git так или иначе отслеживает изменения.
* `modified` Состояние `modified` означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

Типичный жизненный цикл файла в Git:

1. Файл только что создали. Git ещё не отслеживает содержимое этого файла. Состояние: `untracked`.
2. Файл добавили в ** staging area** с помощью `git add`. Состояние: `staged` (+ `tracked`).
  * Возможно, изменили файл ещё раз. Состояния: `staged`, `modified` (+ `tracked`). Обратите внимание: `staged` и `modified` у одного файла, но у разных его версий.
  * Ещё раз выполнили `git add`. Состояние: `staged` (+ `tracked`).
3. Сделали коммит с помощью `git commit`. Состояние: `tracked`.
4. Изменили файл. Состояние: `modified` (+ `tracked`).
5. Снова добавили в ** staging area** с помощью `git add`. Состояния: `staged` (+ `tracked`).
6. Сделали коммит. Состояния: `tracked`.
7. Повторили пункты 4 − 6 много-много раз.

**Как читать git status**

Большинство файлов в типичном проекте будут находиться в состоянии `tracked` (то есть закоммичены и не изменены после коммита). Вы не увидите это состояние в выводе команды `git status` — иначе она бы каждый раз выводила список вообще всех файлов проекта.
В итоге `git status` показывает только следующие состояния файлов:
  * `staged` (Changes to be committed в выводе git status);
  * `modified` (Changes not staged for commit);
  * `untracked` (Untracked files).
  
  **Оформление сообщений к коммитам**
  
 То, как написаны сообщения коммитов, тоже может подчиняться определённым правилам. Иногда эти правила продиктованы культурой команды, а иногда техническими ограничениями.
Например, в выводе команды `git log --oneline` умещается максимум 72 первых символа сообщения, поэтому многие правила включают пункт: «Сообщение не должно быть длиннее 72 символов».

Сообщения коммитов можно сравнить с надписями на коробках в кладовке. Если надписей нет, то нужную коробку будет сложно найти: придётся заглянуть в каждую, чтобы понять, что там. А если надписи есть, то нужная найдётся сразу.  

**Стили оформления**

Без единообразия коммитов нет и эффективной работы в Git. Это может показаться мелочью, но когда коммиты с сообщениями в разных стилях идут друг за другом, их может быть сложно читать.

**Корпоративный**

Во многих компаниях применяется Jira — система для организации проектов и задач. У каждой задачи в Jira есть идентификатор из нескольких заглавных латинских букв и номера. Например, LGS-239 значит, что это 
239-я задача в проекте LGS (сокращение от англ. logistics — «логистика»).
В корпоративном стиле в начале сообщения обычно указывают Jira-ID, а после — текст сообщения.

**Conventional Commits**

Стандарт Conventional Commits (англ. «соглашение о коммитах») отличается качественной документацией и подробной проработкой. Он подходит для репозиториев с исходным кодом программ. Использовать его для других типов проектов (например, для перевода книги) было бы неудобно.
Conventional Commits предлагает такой формат коммита: `<type>: <сообщение>`. Первая часть `type` — это тип изменений. Таких типов достаточно много. Вот два примера:

  * `feat` (сокращение от англ. feature) — для новой функциональности;
  * `fix` (от англ. «исправить», «устранить») — для исправленных ошибок.
Более подробный список можно увидеть на [сайте с описанием этого стиля](https://www.conventionalcommits.org/ru/v1.0.0-beta.4/#спецификация).

**GitHub-стиль**

GitHub можно использовать не только для хранения файлов проекта, но и для ведения списка задач (англ. issue) этого проекта. Если коммит «закрывает» или «решает» какую-то задачу, то в его сообщении удобно указывать ссылку на неё. Для этого в любом месте сообщения нужно указать `#<номер задачи>`.