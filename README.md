# Практическая работа №1. «Делимся проектом с миром»

**Сделать папку репозиторием —** `git init`

**«Разгитить» папку, если что-то пошло не так, —** `rm -rf .git`

**Проверить состояние репозитория —** `git status`

**Подготовить файлы к сохранению —** `git add`

**Например:**
```bash
git add --all
git add readme.txt
```
**Выполнить коммит** — `git commit`

**Просмотреть историю коммитов —** `git log`

**GitHub быстрый старт** (https://docs.github.com/ru/get-started/quickstart)

**Для генерации SSH-пары можно использовать программу ssh-keygen.**

Откройте терминал и введите следующую команду.
```bash
ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub" 
```
**Для добавления сгенерированного ключа:**
1. Перейдите на GitHub и выберите пункт Settings (англ. «настройки») в меню аккаунта.
2. В меню слева нажмите на пункт SSH and GPG keys.
3. В открывшейся вкладке выберите New SSH key (англ. «новый SSH-ключ»).
4. В поле Title (англ. «заголовок») напишите название ключа. Например, Personal key (англ. «личный ключ»).
5. В поле Key type (англ. «тип ключа») должно быть Authentication Key (англ. «ключ аутентификации»).
6. В поле Key скопируйте ваш ключ из файла .pub.
7. Нажмите на кнопку Add SSH key (англ. «добавить SSH-ключ»).
8. Проверьте правильность ключа с помощью следующей команды.
```bash
ssh -T git@github.com 
```
**Привязать удаленный репозиторий к локальному**
```bash
cd ~/dev/first-project
git remote add origin git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ_РЕПОЗИТОРИЯ%.git 
```
**Убедиться, что репозитории связаны, —** `git remote -v`
**Отправить изменения на удалённый репозиторий —** `git push`
```bash
git push -u origin main # Если команда приведёт к ошибке, попробуйте 
                          # заменить main на master.
```						  
**Форматирование README.md** (https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c)

**Хеш — основной идентификатор коммита**

Git хеширует (преобразует) информацию о коммите с помощью алгоритма SHA-1 и получает для каждого коммита свой уникальный хеш — результат хеширования.
Обычно хеш — это короткая (40 символов в случае SHA-1) строка.

Она обладает следующими важными свойствами:

  * если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;
  * если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).	

**Элементы описания коммита**

После вызова `git log` появляется список коммитов. 

Формат вывода:

* строка из цифр и латинских букв после слова commit — это хеш коммита;
* Author — имя автора и его электронная почта;
* Date — дата и время создания коммита;
* в конце находится сообщение коммита.

Получить сокращённый лог можно с помощью команды `git log --oneline`

Сокращённый хеш (то есть первые несколько символов полного) можно использовать точно так же, как и полный. Для этого команда `git log --oneline` автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь.

**HEAD — всему голова**

Файл `HEAD` — один из служебных файлов папки `.git`. Он указывает на коммит, который сделан последним (то есть на самый новый).

Если нужно передать последний коммит, то вместо его хеша можно просто написать слово `HEAD` — Git поймёт, что вы имели в виду последний коммит.

**Статусы файлов в Git**
Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные.

* `untracked` Новые файлы в Git-репозитории помечаются как `untracked`, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У `untracked`-файла нет предыдущих версий, зафиксированных в коммитах или через команду `git add`.
* `staged`  После выполнения команды `git add` файл попадает в ** staging area**, то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии `staged`. ** Staging area** также называют ** index** или ** cache**, а состояние файла `staged` иногда называют `indexed` или `cached`.
* `tracked` Состояние `tracked` — это противоположность `untracked`. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью `git commit`, а также файлы, которые были добавлены в ** staging area** командой `git add`. То есть все файлы, в которых Git так или иначе отслеживает изменения.
* `modified` Состояние `modified` означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

Типичный жизненный цикл файла в Git:

1. Файл только что создали. Git ещё не отслеживает содержимое этого файла. Состояние: `untracked`.
2. Файл добавили в ** staging area** с помощью `git add`. Состояние: `staged` (+ `tracked`).
  * Возможно, изменили файл ещё раз. Состояния: `staged`, `modified` (+ `tracked`). Обратите внимание: `staged` и `modified` у одного файла, но у разных его версий.
  * Ещё раз выполнили `git add`. Состояние: `staged` (+ `tracked`).
3. Сделали коммит с помощью `git commit`. Состояние: `tracked`.
4. Изменили файл. Состояние: `modified` (+ `tracked`).
5. Снова добавили в ** staging area** с помощью `git add`. Состояния: `staged` (+ `tracked`).
6. Сделали коммит. Состояния: `tracked`.
7. Повторили пункты 4 − 6 много-много раз.